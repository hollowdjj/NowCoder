package array

/*
给定一个整数数组，数组中有一个数出现了一次，其他数出现了三次，请找出只出现了一次的数。

输入：[1,2,2,2] 返回值：1
*/

func SingleNumber(nums []int) int {
	/*
		遍历数组，然后将每个数的二进制表达在32个位上的值累加到辅助数组t的相应位置t[i]上。
		说白了，这一步就是在对整个数组统计每一位上有多少个1。
		接下来我们遍历辅助数组t，如果t[i]不是3的倍数，说明那个出现一次的数在这个i位上肯定是1，
		否则这一位上肯定是0。通过或运算，在遍历完成后就能够得到那个只出现一次的数。

		接下来解释一下原因：
		对于某一个i位而言，由于存在n-1个数出现了3次，假设这些出现3次的数中，有一个数在第i位上是1，
		那么这一位上的1就是3次；如果有多个出现3次的数在第i位上是1，那么这一位上1的个数会以3的幅度自增，
		但始终都是3的倍数；如果它们之中没有一个数在第i位上是1，那么t[i]=0，仍然满足t[i]%3=0。
		然后继续考虑只出现了一次的那个数。如果这个数在第i位上为1，那么累加到t[i]上就会导致t[i]%3=1；
		如果这个只出现一次的数在第i位上为0，无论出现3次的数在该位上是否有为1的情况，总会有t[i]%3=0成立。
		因此只要通过计算t[i]%3的值就能够确定那个仅出现一次的数在这一位上是0还是1，从而还原出这个数。
	*/
	arr := make([]int32, 32)
	for _, v := range nums {
		t := int32(v)
		for i := 0; i < 32; i++ {
			arr[i] += (t >> i) & 1
		}
	}

	var ans int32
	for i := 31; i >= 0; i-- {
		if arr[i]%3 == 1 {
			ans |= (1 << i)
		}
	}
	return int(ans)
}
