package string

/*
给出一个长度为 n 的，仅包含字符 '(' 和 ')' 的字符串，计算最长的格式正确的括号子串的长度。

例1: 对于字符串 "(()" 来说，最长的格式正确的子串是 "()" ，长度为 2 .
例2：对于字符串 ")()())" , 来说, 最长的格式正确的子串是 "()()" ，长度为 4 .

字符串长度：0≤n≤5∗10^5
要求时间复杂度O(n),空间复杂度O(n)
*/

func LongestValidParentheses(s string) int {
	//dp[i]表示s[0:i]的最长格式正确括号子串长度。状态转移方程：
	//当s[i] = '('时dp[i] = 0(因为必须要是连续子串)
	//当s[i] = ')' && s[i-1] = '('时 dp[i] = dp[i-2] + 2。例如：.....()
	//当s[i] = ')' && s[i-1] == ')时：
	// 形如  ...(      (....)     )
	//     i-1-dp[i-1]     i-1    i
	//如果s[i-1-dp[i-1]]为')'的话dp[i] = dp[i-1] + 2
	//如果s[i-1-dp[i-1]]为'('的话dp[i] = dp[i-1]+dp[i-1-dp[i-1-1]+2
	n := len(s)
	dp := make([]int, n)
	res := 0
	for i := 0; i < n; i++ {
		if s[i] == ')' {
			if i-1 >= 0 && s[i-1] == '(' {
				if i-2 >= 0 {
					dp[i] = dp[i-2] + 2
				} else {
					dp[i] = 2
				}

			} else if i-1 >= 0 && s[i-1] == ')' {
				if dp[i-1] > 0 && i-1-dp[i-1] >= 0 && s[i-1-dp[i-1]] == '(' {
					if i-1-dp[i-1]-1 >= 0 {
						dp[i] = dp[i-1] + dp[i-1-dp[i-1]-1] + 2
					} else {
						dp[i] = dp[i-1] + 2
					}
				}
			}
		}
		res = max(res, dp[i])
	}
	return res
}
